# ZookeeperTree
Zookeeper相关技术研究
![](https://i.imgur.com/tJXCTBl.png)

Zookeeper集群部署
![](https://i.imgur.com/iPehjdO.png)

<pre>
zookeeper基础
    1）Api概述
    2）znode的不同类型
    3）监视与通知
	
zookeeper架构
    1）zookeeper仲裁
    2）会话
</pre>

<pre>
   Zookeeper从文件系统API得到启发，提供一组简单的API，使得开发人员可以实现通用的协作任务，
包括选举主节点，管理组内成员关系，管理元数据等。
</pre>

<pre>
   Zookeeper并不直接暴露原语，取而代之，它暴露了由一小部分调用方法组成的类似文件系统的API
，以便允许应用实现自己的原语。
</pre>

<pre>
Znode的不同类型
   1）持久节点和零时节点
      Znode节点可以使持久的，也可以是零时的，持久的znode只能通过调用delete来进行删除，
      零时的znode与之相反，当创建该节点的客户端崩溃或者关闭了与Zookeeper的连接时，这个
      节点就会被删除。
 
      持久的znode是一种非常有用的znode，可以通过持久类型的znode为应用保存一些数据，即使
      znode的创建者不再属于应用系统，数据也可以保存下来而不丢失。

   Znode节点分类
      1）持久的
      2）零时的
      3）持久有序的
      5）零时有序的
</pre>

<pre>
监视与通知

    客户端向Zookeeper注册需要接受通知的znode，通过对znode设置监视点来接受通知，监视点是
    一个单次触发的操作，也就是说监视点会触发一个通知，为了接受更多通知，客户端必须在每次
    通知后设置一个新的监视点。

    Zookeeper可以定义不同类型的通知，这依赖于设置监视点对应的通知类型。客户端可以设置多种
    监视点，如监控znode的数据变化，监控znode子节点的变化，监控znode的创建与删除，为了设置
    监视点，可以使用任何API中的调用来读取Zookeeper的状态。在调用这些API时，传入一个
    watcher对象或使用默认的watcher.
</pre>

<pre>
版本
    每个znode都有一个版本号，它随着每次数据变化而递增。两个API操作可以有条件的执行：
       setData, delete  这两个调用以版本号作为传入参数。只有当转入参数的版本号与服务器
    上的版本号一致时调用才会成功。
</pre>

<pre>
Zookeeper的架构

   Zookeeper仲裁模式（多节点的集群模式）
   在仲裁模式下，Zookeeper复制集群中的所有服务器的数据树。但如果一个客户端等待每个服务器完
成数据保存后再继续，延迟问题将无法接受。在公共管理领域，法定人数是指进行一项投票所需的立法
者的最小数量。而在Zookeeper集群中，则是指为了使Zookeeper工作必须有效运行的服务器的最小值。
这个数字也是服务器告知客户端安全保存数据前，需要保存客户端数据的服务器的最小个数。
</pre>

<pre>
会话
   在对Zookeeper集合执行任何请求前，一个客户端必须先与服务端建立会话。客户端提交
给Zookeeper的所有操作均关联正在一个会话上，当一个会话因为某种原因而终止时，在这个会话期间
建立的零时节点就会消失。

   当客户端通过一个特定语言套件来创建一个Zookeeper句柄时，它就会通过服务器建立一个会话。
客户端初始连接到集合中某一个服务器或一个独立的服务器。客户端通过TCP协议域服务器进行连接并
通信，但当会话无法与当前连接的服务器继续通信时，会话就可能转移到另一个服务器上。Zookeeper
客户端透明的转移一个会话到不同的服务器。

   会话提供了顺序保障，这就意味着同一个会话中的请求会以FIFO顺序执行。但是在多个会话之间不
保序。
</pre>

<pre>
会话的状态和声明周期

   1：Connecting
   2: Connected
   3: Closed
   5: NOT_Connected

   创建会话时，你需要设置会话超时时间这个重要的参数，这个参数设置了Zookeeper服务器允许会话
被声明为超时之前存在的时间。如果经过时间t之后服务接收不到这个会话的任何消息，服务就会声明会话
过期。而在客户端，如果经过2/3t时间后，Zookeeper客户端开始寻找其他的服务器，而此时还有t/3的
时间去寻找。

   当尝试连接到一个不同的服务器时，非常重要的是，这个服务器的Zookeeper状态要与最后连接的
服务器的Zookeeper状态保持最新。客户端不能连接到这样的服务器：
   它未发现更新而客户端已经发现的更新。
   Zookeeper通过在服务器中排序更新操作来决定状态是否最新。Zookeeper确保每一个变化相对于
所有其他已执行的更新是完全有序的。
   在Zookeeper实现中，系统根据每一个更新建立的顺序来分配给事务标识符。
</pre>

<pre>
通过创建零时节点的方式，使用Zookeeper实现分布式锁。
</pre>

<pre>
群首选举和外部资源

   Zookeeper为所有客户端提供了系统的一致性视图，只要客户端与Zookeeper进行任何交互操作，
Zookeeper都会保持同步。然而Zookeeper无法保护与外部设备的交互操作，这种缺乏保护的特殊问题
的说明，在实际环境中也经常被发现，常常用于主机过载的情况下。

   当运行客户端进程的主机发生过载，就会开始发生交换，系统颠覆或因已经超负载的主机资源的竞争
而导致的进程延迟，这些都会影响与Zookeeper交互的及时性。
   一方面，Zookeeper无法及时地与Zookeeper服务器发送心跳消息，导致Zookeeper的会话超时。
   另一方面，主机上本地线程的调度会导致不可预知的调度：一个应用线程认为会话仍处于活动状态，
并持有主节点，即使Zookeeper线程有机会运行时才会通知会话已经超时。
</pre>

<pre>
角色
   1) 群首
   2）追随者
   3）观察者
      观察者不会参与决策哪些请求可被接受的过程，只是观察决策的结果。

   Zookeeper服务器会在本地处理只读请求，加入一个服务器接收到客户端的getData请求，服务器读
取该状态信息，并将这些信息返回给客户端。因为服务器会在本地处理请求，所以Zookeeper在处理以
只读为主要负载时，性能会很高。我们还可以增加更多的服务器到Zookeeper集群中，这样就可以处理
更多的请求，大幅提高整理处理能力。

   那些会改变Zookeeper状态的客户端请求（create, delete, setData）将会被转发给群首，群首
执行相应的请求，并形成状态的更新，我们称为事务。

   请求的事务包含了两个重要字段：
       1：节点中心的数据字段值
       2：该节点的版本号。

   当处理该事务时，服务端将会使用十五中的数据信息替换节点中原来的数据信息，并会用事务中的
版本号更新该节点，而不是增加版本号的值。

   一个事务为一个单位，也就是说所有的变更处理需要以原子方式执行。
   同时一个事务还有幂等性，也就是说，我们可以对同一个事务执行两次，我们得到的结果还是一样的
。
   当群首产生了一个事务，就会为该事务分配一个标识符，我们称之为Zookeeper会话ID(zxid)，通
过Zxid对事务进行标识，就可以按照群首所指定的顺序在各个服务器中按序执行。服务器之间在进行新的
群首选举时也会交换zxid信息，这样就可以知道哪个服务器接收了更多的事务，并可以同步他们之间的
状态信息。
   zxid为一个long64位的整数，分为两部分：
       时间戳
       计数器
</pre>

<pre>
群首选举策略

     群首为集群中的服务器选择出来的一个服务器，并会一直被集群所认可。设置群首的目的是为了
对客户端发起的ZooKeeper状态变更请求进行排序，包括create, setData, delete操作，群首为
每个请求转换为一个事务，将这些事务发送给追随者，确保集群按照群首确定的顺序接收并处理这些
事务。
     法定数量是能够交错在一起，以避免我们所说的脑裂问题。

     每个服务器启动之后进入LOOKING状态，开始选举一个新的群首或者查找已经存在的群首，如果群
  首已经存在，其他服务器就会通知这个新启动的服务器，告知哪个服务器时群首，与此同时，新的服务
  器会与群首建立连接，以确保自己的状态与群首保持一致。

     如果所有的服务器均处于LOOKING状态，这些服务器之间就会进行通信来选举出一个群首，通过信
  息交换对群首选举达成共识的选择，在本次选举过程中胜出的服务器就进入LEADING状态，而集群中
  的其他服务器进入FOLLOWING状态。

     对群首的选举的信息，我们称之为群首选举通知消息。该协议非常简单，当一个服务器进
  入LOOKING状态，就会发送向集群中每个服务器发送一个通知消息，该消息包括该服务器的投票信息，
  投票中包含服务器标识符(sid)和最近执行的事务的zxid信息。
     
     当一个服务器接收到一个投票信息，该服务器将会根据以下规则修改自己的投票信息
     1）将接收的voteid和votezxid作为一个标识符，并获取接收方当前的投票中的zxid，
        用myZxid和mySid标识接收方服务器自己的值。
     2）如果votezxid > myzxid或者  votezxid = myzxid且voteid > mysid
        则保留当前的投票信息
     3）否则，修改自己的投票信息，将votezxid赋值给myZxid，将voteId赋值给mySid

     简而言之，只有最新的服务器将赢得选举，因为其拥有最近一次的zxid，如果多个服务器拥有
  最大的zxid，其中的sid值最大的服务器将赢得选举。
</pre>

<pre>
Zab：状态更新的广播协议
</pre>