# ZookeeperTree
Zookeeper相关技术研究
![](https://i.imgur.com/tJXCTBl.png)

Zookeeper集群部署
![](https://i.imgur.com/iPehjdO.png)

<pre>
zookeeper基础
    1）Api概述
    2）znode的不同类型
    3）监视与通知
	
zookeeper架构
    1）zookeeper仲裁
    2）会话
</pre>

<pre>
   Zookeeper从文件系统API得到启发，提供一组简单的API，使得开发人员可以实现通用的协作任务，
包括选举主节点，管理组内成员关系，管理元数据等。
</pre>

<pre>
   Zookeeper并不直接暴露原语，取而代之，它暴露了由一小部分调用方法组成的类似文件系统的API
，以便允许应用实现自己的原语。
</pre>

<pre>
Znode的不同类型
   1）持久节点和零时节点
      Znode节点可以使持久的，也可以是零时的，持久的znode只能通过调用delete来进行删除，
      零时的znode与之相反，当创建该节点的客户端崩溃或者关闭了与Zookeeper的连接时，这个
      节点就会被删除。
 
      持久的znode是一种非常有用的znode，可以通过持久类型的znode为应用保存一些数据，即使
      znode的创建者不再属于应用系统，数据也可以保存下来而不丢失。

   Znode节点分类
      1）持久的
      2）零时的
      3）持久有序的
      5）零时有序的
</pre>

<pre>
监视与通知

    客户端向Zookeeper注册需要接受通知的znode，通过对znode设置监视点来接受通知，监视点是
    一个单次触发的操作，也就是说监视点会触发一个通知，为了接受更多通知，客户端必须在每次
    通知后设置一个新的监视点。

    Zookeeper可以定义不同类型的通知，这依赖于设置监视点对应的通知类型。客户端可以设置多种
    监视点，如监控znode的数据变化，监控znode子节点的变化，监控znode的创建与删除，为了设置
    监视点，可以使用任何API中的调用来读取Zookeeper的状态。在调用这些API时，传入一个
    watcher对象或使用默认的watcher.
</pre>

<pre>
版本
    每个znode都有一个版本号，它随着每次数据变化而递增。两个API操作可以有条件的执行：
       setData, delete  这两个调用以版本号作为传入参数。只有当转入参数的版本号与服务器
    上的版本号一致时调用才会成功。
</pre>

<pre>
Zookeeper的架构

   Zookeeper仲裁模式（多节点的集群模式）
   在仲裁模式下，Zookeeper复制集群中的所有服务器的数据树。但如果一个客户端等待每个服务器完
成数据保存后再继续，延迟问题将无法接受。在公共管理领域，法定人数是指进行一项投票所需的立法
者的最小数量。而在Zookeeper集群中，则是指为了使Zookeeper工作必须有效运行的服务器的最小值。
这个数字也是服务器告知客户端安全保存数据前，需要保存客户端数据的服务器的最小个数。
</pre>

<pre>
会话
   在对Zookeeper集合执行任何请求前，一个客户端必须先与服务端建立会话。客户端提交
给Zookeeper的所有操作均关联正在一个会话上，当一个会话因为某种原因而终止时，在这个会话期间
建立的零时节点就会消失。

   当客户端通过一个特定语言套件来创建一个Zookeeper句柄时，它就会通过服务器建立一个会话。
客户端初始连接到集合中某一个服务器或一个独立的服务器。客户端通过TCP协议域服务器进行连接并
通信，但当会话无法与当前连接的服务器继续通信时，会话就可能转移到另一个服务器上。Zookeeper
客户端透明的转移一个会话到不同的服务器。

   会话提供了顺序保障，这就意味着同一个会话中的请求会以FIFO顺序执行。但是在多个会话之间不
保序。
</pre>

<pre>
会话的状态和声明周期

   
</pre>